{
    "docs": [
        {
            "location": "/", 
            "text": "Exekube documentation\n\n\nExekube is an \"Infrastructure as Code\" modular framework for managing Kubernetes, built with Terraform and Helm.\n\n\nIntroduction\n\n\n\n\nWhat is Exekube?\n\n\nHow does Exekube compare to other software?\n\n\n\n\nSetup and Installation\n\n\n\n\nCreate an Exekube project on Google Cloud Platform\n\n\nCreate an Exekube project on Amazon Web Services\n\n\n\n\nUsage\n\n\n\n\nDeploy an application on Kubernetes with Exekube\n\n\n\n\nReference\n\n\n\n\ngcp-gke module\n\n\nhelm-release module\n\n\n\n\nMiscellaneous\n\n\n\n\nHow to configure a Helm release\n\n\nUse HashiCorp Vault to manage secrets\n\n\nRead the project's feature tracker\n\n\nManaging secrets in Exekube", 
            "title": "Overview"
        }, 
        {
            "location": "/#exekube-documentation", 
            "text": "Exekube is an \"Infrastructure as Code\" modular framework for managing Kubernetes, built with Terraform and Helm.", 
            "title": "Exekube documentation"
        }, 
        {
            "location": "/#introduction", 
            "text": "What is Exekube?  How does Exekube compare to other software?", 
            "title": "Introduction"
        }, 
        {
            "location": "/#setup-and-installation", 
            "text": "Create an Exekube project on Google Cloud Platform  Create an Exekube project on Amazon Web Services", 
            "title": "Setup and Installation"
        }, 
        {
            "location": "/#usage", 
            "text": "Deploy an application on Kubernetes with Exekube", 
            "title": "Usage"
        }, 
        {
            "location": "/#reference", 
            "text": "gcp-gke module  helm-release module", 
            "title": "Reference"
        }, 
        {
            "location": "/#miscellaneous", 
            "text": "How to configure a Helm release  Use HashiCorp Vault to manage secrets  Read the project's feature tracker  Managing secrets in Exekube", 
            "title": "Miscellaneous"
        }, 
        {
            "location": "/introduction/what-is-exekube/", 
            "text": "What is Exekube?\n\n\nExekube\n is a declarative \"Infrastructure as Code\" framework (a.k.a. platform / PaaS) for managing cloud infrastructure (notably Kubernetes clusters) and deploying containerized software onto that infrastructure.\n\n\nThe declarative workflow\n\n\nRight after you enable billing on a cloud platform like Amazon Web Services or Google Cloud Platform, you are able to run one command\n\n\nxk apply\n\n\n\n\nin order to:\n\n\n\n\nCreate a Kubernetes cluster and supporting resources on the cloud platform\n\n\nDeploy any number of Kubernetes resources onto the cluster (as Helm releases)\n\n\n\n\nWhen it's time to upgrade some of your cloud resources, just modify your code and run \nxk apply\n again. Terraform will match the state of your code to the state of your cloud resources.\n\n\nTo clean up, run \nxk destroy\n and the whole thing is gone from the cloud.\n\n\nFeatures\n\n\nExekube offers you:\n\n\n\n\nFull control over your cloud infrastructure (via Terraform)\n\n\nFull control over your container orchestration (via Terraform + Helm)\n\n\nFully automated one-click-to-deploy experience\n\n\nModular design and declarative model of management\n\n\nFreedom to choose a cloud provider to host Kubernetes\n\n\nContinuous integration (CI) facilities out of the box\n\n\n\n\nComponents\n\n\nThe framework is distributed as a \nDocker image on DockerHub\n that can be used manually by DevOps engineers or automatically via continuous integration (CI) pipelines. It combines several open-source DevOps tools into one easy-to-use workflow for managing cloud infrastructure and Kubernetes resources.\n\n\nDevOps tools\n\n\n\n\n\n\n\n\nComponent\n\n\nRole\n\n\n\n\n\n\n\n\n\n\nDocker\n\n\nLocal and cloud container runtime\n\n\n\n\n\n\nDocker Compose\n\n\nLocal development enviroment manager\n\n\n\n\n\n\nTerraform\n\n\nDeclarative cloud infrastructure manager\n\n\n\n\n\n\nTerragrunt\n\n\nTerraform \nlive module\n manager\n\n\n\n\n\n\nKubernetes\n\n\nContainer orchestrator\n\n\n\n\n\n\nHelm\n\n\nKubernetes package (chart / release) manager\n\n\n\n\n\n\n\n\nDefault Helm packages installed\n\n\n\n\n\n\n\n\nComponent\n\n\nPurpose\n\n\n\n\n\n\n\n\n\n\nNGINX Ingress Controller\n\n\nCluster ingress controller\n\n\n\n\n\n\nkube-lego\n\n\nAutomatic Let's Encrypt TLS certificates for Ingress\n\n\n\n\n\n\nHashiCorp Vault (TBD)\n\n\nCluster secret management\n\n\n\n\n\n\nDocker Registry\n\n\nContainer image registry\n\n\n\n\n\n\nChartMuseum\n\n\nHelm chart repository\n\n\n\n\n\n\nJenkins, Drone, or Concourse\n\n\nContinuous integration", 
            "title": "What is Exekube?"
        }, 
        {
            "location": "/introduction/what-is-exekube/#what-is-exekube", 
            "text": "Exekube  is a declarative \"Infrastructure as Code\" framework (a.k.a. platform / PaaS) for managing cloud infrastructure (notably Kubernetes clusters) and deploying containerized software onto that infrastructure.", 
            "title": "What is Exekube?"
        }, 
        {
            "location": "/introduction/what-is-exekube/#the-declarative-workflow", 
            "text": "Right after you enable billing on a cloud platform like Amazon Web Services or Google Cloud Platform, you are able to run one command  xk apply  in order to:   Create a Kubernetes cluster and supporting resources on the cloud platform  Deploy any number of Kubernetes resources onto the cluster (as Helm releases)   When it's time to upgrade some of your cloud resources, just modify your code and run  xk apply  again. Terraform will match the state of your code to the state of your cloud resources.  To clean up, run  xk destroy  and the whole thing is gone from the cloud.", 
            "title": "The declarative workflow"
        }, 
        {
            "location": "/introduction/what-is-exekube/#features", 
            "text": "Exekube offers you:   Full control over your cloud infrastructure (via Terraform)  Full control over your container orchestration (via Terraform + Helm)  Fully automated one-click-to-deploy experience  Modular design and declarative model of management  Freedom to choose a cloud provider to host Kubernetes  Continuous integration (CI) facilities out of the box", 
            "title": "Features"
        }, 
        {
            "location": "/introduction/what-is-exekube/#components", 
            "text": "The framework is distributed as a  Docker image on DockerHub  that can be used manually by DevOps engineers or automatically via continuous integration (CI) pipelines. It combines several open-source DevOps tools into one easy-to-use workflow for managing cloud infrastructure and Kubernetes resources.", 
            "title": "Components"
        }, 
        {
            "location": "/introduction/what-is-exekube/#devops-tools", 
            "text": "Component  Role      Docker  Local and cloud container runtime    Docker Compose  Local development enviroment manager    Terraform  Declarative cloud infrastructure manager    Terragrunt  Terraform  live module  manager    Kubernetes  Container orchestrator    Helm  Kubernetes package (chart / release) manager", 
            "title": "DevOps tools"
        }, 
        {
            "location": "/introduction/what-is-exekube/#default-helm-packages-installed", 
            "text": "Component  Purpose      NGINX Ingress Controller  Cluster ingress controller    kube-lego  Automatic Let's Encrypt TLS certificates for Ingress    HashiCorp Vault (TBD)  Cluster secret management    Docker Registry  Container image registry    ChartMuseum  Helm chart repository    Jenkins, Drone, or Concourse  Continuous integration", 
            "title": "Default Helm packages installed"
        }, 
        {
            "location": "/introduction/exekube-vs-other/", 
            "text": "Compare Exekube to other software\n\n\n\n\nWarning\n\n\nThis article is incomplete. Want to help? \nSubmit a pull request\n.\n\n\n\n\nDeclarative vs imperative workflows\n\n\nLegacy imperative workflow\n\n\nCommand line tools \nkubectl\n and \nhelm\n are known to those who are familiar with Kubernetes. \ngcloud\n (part of Google Cloud SDK) is used for managing the Google Cloud Platform.\n\n\n\n\nxk gcloud \ngroup\n \ncommand\n \narguments\n \nflags\n\n\nxk kubectl \ngroup\n \ncommand\n \narguments\n \nflags\n\n\nxk helm \ncommand\n \narguments\n \nflags\n\n\n\n\nExamples:\n\n\nxk gcloud auth list\n\nxk kubectl get nodes\n\nxk helm install --name custom-rails-app \n\\\n\n        -f live/prod/kube/apps/my-app/values.yaml \n\\\n\n        charts/rails-app\n\n\n\n\nDeclarative workflow\n\n\n\n\nxk apply\n\n\nxk destroy\n\n\n\n\nDeclarative tools are exact equivalents of stadard CLI tools like \ngcloud\n / \naws\n, \nkubectl\n, and \nhelm\n, except everything is implemented as a \nTerraform provider plugin\n and expressed as declarative HCL (HashiCorp Configuration Language) code.", 
            "title": "Exekube in comparison"
        }, 
        {
            "location": "/introduction/exekube-vs-other/#compare-exekube-to-other-software", 
            "text": "Warning  This article is incomplete. Want to help?  Submit a pull request .", 
            "title": "Compare Exekube to other software"
        }, 
        {
            "location": "/introduction/exekube-vs-other/#declarative-vs-imperative-workflows", 
            "text": "", 
            "title": "Declarative vs imperative workflows"
        }, 
        {
            "location": "/introduction/exekube-vs-other/#legacy-imperative-workflow", 
            "text": "Command line tools  kubectl  and  helm  are known to those who are familiar with Kubernetes.  gcloud  (part of Google Cloud SDK) is used for managing the Google Cloud Platform.   xk gcloud  group   command   arguments   flags  xk kubectl  group   command   arguments   flags  xk helm  command   arguments   flags   Examples:  xk gcloud auth list\n\nxk kubectl get nodes\n\nxk helm install --name custom-rails-app  \\ \n        -f live/prod/kube/apps/my-app/values.yaml  \\ \n        charts/rails-app", 
            "title": "Legacy imperative workflow"
        }, 
        {
            "location": "/introduction/exekube-vs-other/#declarative-workflow", 
            "text": "xk apply  xk destroy   Declarative tools are exact equivalents of stadard CLI tools like  gcloud  /  aws ,  kubectl , and  helm , except everything is implemented as a  Terraform provider plugin  and expressed as declarative HCL (HashiCorp Configuration Language) code.", 
            "title": "Declarative workflow"
        }, 
        {
            "location": "/setup/gcp-gke/", 
            "text": "Setup Exekube with Google Cloud and GKE\n\n\nRequirements starting from zero\n\n\n\n\nFor Linux users, \nDocker CE\n and \nDocker Compose\n are sufficient\n\n\nFor macOS users, \nDocker for Mac\n is sufficient\n\n\nFor Windows users, \nDocker for Windows\n is sufficient\n\n\n\n\nStep-by-step instructions\n\n\n\n\n\n\nFirst, create an alias for your shell session (\nxk\n stands for \"exekube\"):\n\n\nalias\n \nxk\n=\n. .env \n docker-compose run --rm exekube\n\n\n\n\n\n\n\n\n\nIf you don't have one, create a \nGoogle Account\n. Then, create a new Google Cloud Platform \nProject\n.\n\n\n\n\n\n\n\n\nProject name\n\n\nProject ID\n\n\n\n\n\n\n\n\n\n\nProduction Environment\n\n\nprod-env-20180101\n\n\n\n\n\n\n\n\n\n\n\n\nRename \n.env.example\n file in repo root to \n.env\n. Set the \nTF_VAR_gcp_project\n variable to the value from previous step.\n\n\nmv .env.example .env\n\n\n\n\nexport XK_LIVE_DIR=\n/exekube/live/prod\n\n\n- export TF_VAR_gcp_project=\nmy-project-186217\n\n\n+ export TF_VAR_gcp_project=\nprod-env-20180101\n\nexport TF_VAR_gcp_remote_state_bucket=\n${TF_VAR_gcp_project}-tfstate\n\n\n\n\n\n\n\n\n\nCreate a service account\n and give it project owner permissions. Download the account JSON private key file to repo root directory and rename the file to \ncredentials.json\n.\n\n\n\n\n\n\n\n\nRun this command authenticate us to \ngcloud\n:\n\n\nxk gcloud auth activate-service-account --key-file credentials.json \n\\\n\n\n rm -rf credentials.json\n\n\n\n\n\n\n\n\nFinally, create a Google Cloud Storage bucket (with versioning) for our Terraform remote state:\n\n\nxk gsutil mb \n\\\n\n        -p \n${\nTF_VAR_gcp_project\n}\n \n\\\n\n        gs://\n${\nTF_VAR_gcp_remote_state_bucket\n}\n \n\\\n\n\n xk gsutil versioning \nset\n on \n\\\n\n        gs://\n${\nTF_VAR_gcp_remote_state_bucket\n}", 
            "title": "On Google Cloud Platform"
        }, 
        {
            "location": "/setup/gcp-gke/#setup-exekube-with-google-cloud-and-gke", 
            "text": "", 
            "title": "Setup Exekube with Google Cloud and GKE"
        }, 
        {
            "location": "/setup/gcp-gke/#requirements-starting-from-zero", 
            "text": "For Linux users,  Docker CE  and  Docker Compose  are sufficient  For macOS users,  Docker for Mac  is sufficient  For Windows users,  Docker for Windows  is sufficient", 
            "title": "Requirements starting from zero"
        }, 
        {
            "location": "/setup/gcp-gke/#step-by-step-instructions", 
            "text": "First, create an alias for your shell session ( xk  stands for \"exekube\"):  alias   xk = . .env   docker-compose run --rm exekube     If you don't have one, create a  Google Account . Then, create a new Google Cloud Platform  Project .     Project name  Project ID      Production Environment  prod-env-20180101       Rename  .env.example  file in repo root to  .env . Set the  TF_VAR_gcp_project  variable to the value from previous step.  mv .env.example .env  export XK_LIVE_DIR= /exekube/live/prod  - export TF_VAR_gcp_project= my-project-186217  + export TF_VAR_gcp_project= prod-env-20180101 \nexport TF_VAR_gcp_remote_state_bucket= ${TF_VAR_gcp_project}-tfstate     Create a service account  and give it project owner permissions. Download the account JSON private key file to repo root directory and rename the file to  credentials.json .     Run this command authenticate us to  gcloud :  xk gcloud auth activate-service-account --key-file credentials.json  \\   rm -rf credentials.json    Finally, create a Google Cloud Storage bucket (with versioning) for our Terraform remote state:  xk gsutil mb  \\ \n        -p  ${ TF_VAR_gcp_project }   \\ \n        gs:// ${ TF_VAR_gcp_remote_state_bucket }   \\   xk gsutil versioning  set  on  \\ \n        gs:// ${ TF_VAR_gcp_remote_state_bucket }", 
            "title": "Step-by-step instructions"
        }, 
        {
            "location": "/setup/aws-eks/", 
            "text": "Setup Exekube with Amazon Web Services\n\n\nUse kops\n\n\n\n\nMissing\n\n\nThis section has not been written yet. Want to help? \nSubmit a pull request\n.\n\n\n\n\nUse EKS (Elastic Container Service for Kubernetes)\n\n\n\n\nMissing\n\n\nThis section has not been written yet. Want to help? \nSubmit a pull request\n.", 
            "title": "On Amazon Web Services"
        }, 
        {
            "location": "/setup/aws-eks/#setup-exekube-with-amazon-web-services", 
            "text": "", 
            "title": "Setup Exekube with Amazon Web Services"
        }, 
        {
            "location": "/setup/aws-eks/#use-kops", 
            "text": "Missing  This section has not been written yet. Want to help?  Submit a pull request .", 
            "title": "Use kops"
        }, 
        {
            "location": "/setup/aws-eks/#use-eks-elastic-container-service-for-kubernetes", 
            "text": "Missing  This section has not been written yet. Want to help?  Submit a pull request .", 
            "title": "Use EKS (Elastic Container Service for Kubernetes)"
        }, 
        {
            "location": "/usage/deploy-app/", 
            "text": "Deploy an application on Kubernetes with Exekube\n\n\n\n\nWarning\n\n\nThis article is incomplete. Want to help? \nSubmit a pull request\n.\n\n\n\n\n\n\n\n\nEdit code in \nlive\n:\n\n\n\n\nImportant\n\n\nIf you cloned / forked this repo, you'll need to have a domain name (DNS zone) like \nexample.com\n and have CloudFlare DNS servers set up for it. Then, in your text editor, search and replace \nswarm.pw\n with your domain zone.\n\n\n\n\nGuide to Terraform / Terragrunt, HCL, and Exekube directory structure\n\n\n\n\n\n\nApply all \nTerraform live modules\n \u2014 create all cloud infrastructure and all Kubernetes resources:\n\n\nxk apply\n\n+ ...\n\n\n+ Module /exekube/live/prod/kube/apps/rails-app has finished successfully!\n\n\n\n\n\n\n\n\n\nEnable the Kubernetes dashboard at \nhttp://localhost:8001/ui\n:\n\n\ndocker-compose up -d\n\n\n\n\n\n\n\n\nGo to \nhttps://my-app.YOURDOMAIN.COM/\n to check that a hello-world Rails app is running.\n\n\n\n\n\n\nUpgrade the Rails application Docker image version in \nlive/kube/apps/my-app/values.yaml\n:\n\n\n replicaCount: 2\n image:\n   repository: ilyasotkov/rails-react-boilerplate\n\n-  tag: \n0.1.0\n\n\n+  tag: \n0.2.0\n\n   pullPolicy: Always\n\n\n\n\nUpgrade the state of real-world cloud resources to the state of our code in \nlive/prod\n directory:\n\nxk apply\n\n\nGo back to your browser and check how your app updated with zero downtime! \ud83d\ude0e\n\n\n\n\n\n\nExperiment with creating, upgrading, and destroying single live modules and groups of live modules:\n\n\nxk destroy live/prod/kube/apps/rails-app/\nxk destroy live/prod/kube/apps/\n\nxk apply live/prod/kube/\nxk apply live/prod/kube/apps/rails-app/\n\n\n\n\n\n\n\n\nClean everything up:\n\n\n# Destroy all cloud provider and Kubernetes resources\n\nxk destroy", 
            "title": "Deploy an application"
        }, 
        {
            "location": "/usage/deploy-app/#deploy-an-application-on-kubernetes-with-exekube", 
            "text": "Warning  This article is incomplete. Want to help?  Submit a pull request .     Edit code in  live :   Important  If you cloned / forked this repo, you'll need to have a domain name (DNS zone) like  example.com  and have CloudFlare DNS servers set up for it. Then, in your text editor, search and replace  swarm.pw  with your domain zone.   Guide to Terraform / Terragrunt, HCL, and Exekube directory structure    Apply all  Terraform live modules  \u2014 create all cloud infrastructure and all Kubernetes resources:  xk apply + ...  + Module /exekube/live/prod/kube/apps/rails-app has finished successfully!     Enable the Kubernetes dashboard at  http://localhost:8001/ui :  docker-compose up -d    Go to  https://my-app.YOURDOMAIN.COM/  to check that a hello-world Rails app is running.    Upgrade the Rails application Docker image version in  live/kube/apps/my-app/values.yaml :   replicaCount: 2\n image:\n   repository: ilyasotkov/rails-react-boilerplate -  tag:  0.1.0  +  tag:  0.2.0 \n   pullPolicy: Always  Upgrade the state of real-world cloud resources to the state of our code in  live/prod  directory: xk apply \nGo back to your browser and check how your app updated with zero downtime! \ud83d\ude0e    Experiment with creating, upgrading, and destroying single live modules and groups of live modules:  xk destroy live/prod/kube/apps/rails-app/\nxk destroy live/prod/kube/apps/\n\nxk apply live/prod/kube/\nxk apply live/prod/kube/apps/rails-app/    Clean everything up:  # Destroy all cloud provider and Kubernetes resources \nxk destroy", 
            "title": "Deploy an application on Kubernetes with Exekube"
        }, 
        {
            "location": "/misc/configure-helm-release/", 
            "text": "Rails app live module example\n\n\nhttps://github.com/ilyasotkov/exekube/tree/feature/vault/live/prod/kube/apps/rails-app\n\n\nHere is a quick example of how you'd configure a Rails application Helm release using Exekube (this is a part of a of a \n\"live\" Terraform module\n, expressed in HashiCorp Configuration Language (HCL):\n\n\ncd\n live/prod/kube/apps/rails-app/\ntree .\n.\n\u251c\u2500\u2500 inputs.tfvars\n\u251c\u2500\u2500 terraform.tfvars\n\u2514\u2500\u2500 values.yaml\n\n\n\n\n# cat terraform.tfvars\n\n\n\nterragrunt\n \n=\n \n{\n\n  \nterraform\n \n{\n\n\n    source\n \n=\n \n/exekube/modules//helm-release\n\n  \n}\n\n\n  \ndependencies\n \n{\n\n\n    paths\n \n=\n \n[\n\n      \n../../../infra/gcp-gke\n,\n\n      \n../../core/ingress-controller\n,\n\n      \n../../core/kube-lego\n,\n\n      \n../../ci/chartmuseum\n,\n\n      \n../../ci/docker-registry\n,\n\n    \n]\n\n  \n}\n\n\n\n  include\n \n=\n \n{\n\n\n    path\n \n=\n \n${find_in_parent_folders()}\n\n  \n}\n\n\n}\n\n\n\n\n\n# cat inputs.tfvars\n\n\n\nrelease_spec\n \n=\n \n{\n\n\n  enabled\n        \n=\n \ntrue\n\n\n  domain_name\n    \n=\n \nrails-app.swarm.pw\n\n\n\n  release_name\n   \n=\n \nrails-app\n\n\n  release_values\n \n=\n \nvalues.yaml\n\n\n\n  chart_repo\n    \n=\n \nprivate\n\n\n  chart_name\n    \n=\n \nrails-app\n\n\n  chart_version\n \n=\n \n0.1.1\n\n\n}\n\n\n\n\n\n# cat values.yaml\n\n\n\nreplicaCount\n:\n \n2\n\n\nimage\n:\n\n  \nrepository\n:\n \nilyasotkov/rails-react-boilerplate\n\n  \ntag\n:\n \n0.1.0\n\n  \npullPolicy\n:\n \nAlways\n\n\ningress\n:\n\n  \nenabled\n:\n \ntrue\n\n  \nannotations\n:\n\n    \nkubernetes.io/ingress.class\n:\n \nnginx\n\n    \nkubernetes.io/tls-acme\n:\n \ntrue\n\n  \nhosts\n:\n\n    \n-\n \n${domain_name}\n\n  \ntls\n:\n\n    \n-\n \nsecretName\n:\n \n${domain_name}-tls\n\n      \nhosts\n:\n\n        \n-\n \n${domain_name}\n\n\npostgresql\n:\n\n  \npersistence\n:\n\n    \nenabled\n:\n \ntrue\n\n  \npostgresUser\n:\n \npostgres\n\n  \npostgresPassword\n:\n \npostgres", 
            "title": "Configure a Helm release"
        }, 
        {
            "location": "/misc/configure-helm-release/#rails-app-live-module-example", 
            "text": "https://github.com/ilyasotkov/exekube/tree/feature/vault/live/prod/kube/apps/rails-app  Here is a quick example of how you'd configure a Rails application Helm release using Exekube (this is a part of a of a  \"live\" Terraform module , expressed in HashiCorp Configuration Language (HCL):  cd  live/prod/kube/apps/rails-app/\ntree .\n.\n\u251c\u2500\u2500 inputs.tfvars\n\u251c\u2500\u2500 terraform.tfvars\n\u2514\u2500\u2500 values.yaml  # cat terraform.tfvars  terragrunt   =   { \n   terraform   {      source   =   /exekube/modules//helm-release \n   } \n\n   dependencies   {      paths   =   [ \n       ../../../infra/gcp-gke , \n       ../../core/ingress-controller , \n       ../../core/kube-lego , \n       ../../ci/chartmuseum , \n       ../../ci/docker-registry , \n     ] \n   }    include   =   {      path   =   ${find_in_parent_folders()} \n   }  }   # cat inputs.tfvars  release_spec   =   {    enabled          =   true    domain_name      =   rails-app.swarm.pw    release_name     =   rails-app    release_values   =   values.yaml    chart_repo      =   private    chart_name      =   rails-app    chart_version   =   0.1.1  }   # cat values.yaml  replicaCount :   2  image : \n   repository :   ilyasotkov/rails-react-boilerplate \n   tag :   0.1.0 \n   pullPolicy :   Always  ingress : \n   enabled :   true \n   annotations : \n     kubernetes.io/ingress.class :   nginx \n     kubernetes.io/tls-acme :   true \n   hosts : \n     -   ${domain_name} \n   tls : \n     -   secretName :   ${domain_name}-tls \n       hosts : \n         -   ${domain_name}  postgresql : \n   persistence : \n     enabled :   true \n   postgresUser :   postgres \n   postgresPassword :   postgres", 
            "title": "Rails app live module example"
        }, 
        {
            "location": "/misc/vault-integration/", 
            "text": "Example implementation by CoreOS Tectonic\n\n\nhttps://coreos.com/tectonic/docs/latest/account/create-account.html", 
            "title": "Use HashiCorp Vault to manage secrets"
        }, 
        {
            "location": "/misc/vault-integration/#example-implementation-by-coreos-tectonic", 
            "text": "https://coreos.com/tectonic/docs/latest/account/create-account.html", 
            "title": "Example implementation by CoreOS Tectonic"
        }, 
        {
            "location": "/misc/feature-tracker/", 
            "text": "Feature tracker\n\n\nFeatures are marked with \u2714\ufe0f when they enter the \nalpha stage\n, meaning a minimum viable solution has been implemented\n\n\nCloud provider and local environment setup\n\n\n\n\n Create GCP account, enable billing in GCP Console (web GUI)\n\n\n Get credentials for GCP (\ncredentials.json\n)\n\n\n Authenticate to GCP using \ncredentials.json\n (for \ngcloud\n and \nterraform\n use)\n\n\n Enable terraform remote state in a Cloud Storage bucket\n\n\n\n\nCloud provider config\n\n\n\n\n Create GCP Folders and Projects and associated policies\n\n\n Create GCP IAM Service Accounts and IAM Policies for the Project\n\n\n\n\nCluster creation\n\n\n\n\n Create the GKE cluster\n\n\n Get cluster credentials (\n/root/.kube/config\n file)\n\n\n Initialize Helm\n\n\n\n\nCluster access control\n\n\n\n\n Add cluster namespaces (virtual clusters)\n\n\n Add cluster roles and role bindings\n\n\n Add cluster network policies\n\n\n\n\nSupporting tools\n\n\n\n\n Install cluster ingress controller (cloud load balancer)\n\n\n Install TLS certificates controller (kube-lego)\n\n\n Install Continuous Delivery tools\n\n\n Continuous delivery service (Drone / Jenkins)\n\n\n Helm chart repository (ChartMuseum)\n\n\n Private Docker registry\n\n\n Git service (Gitlab / Gogs)\n\n\n\n\n\n\n Monitoring and alerting tools (Prometheus / Grafana)\n\n\n\n\nUser apps and services\n\n\n\n\n Install \"hello-world\" apps like static sites, Ruby on Rails apps, etc.", 
            "title": "Project feature tracker"
        }, 
        {
            "location": "/misc/feature-tracker/#feature-tracker", 
            "text": "Features are marked with \u2714\ufe0f when they enter the  alpha stage , meaning a minimum viable solution has been implemented", 
            "title": "Feature tracker"
        }, 
        {
            "location": "/misc/feature-tracker/#cloud-provider-and-local-environment-setup", 
            "text": "Create GCP account, enable billing in GCP Console (web GUI)   Get credentials for GCP ( credentials.json )   Authenticate to GCP using  credentials.json  (for  gcloud  and  terraform  use)   Enable terraform remote state in a Cloud Storage bucket", 
            "title": "Cloud provider and local environment setup"
        }, 
        {
            "location": "/misc/feature-tracker/#cloud-provider-config", 
            "text": "Create GCP Folders and Projects and associated policies   Create GCP IAM Service Accounts and IAM Policies for the Project", 
            "title": "Cloud provider config"
        }, 
        {
            "location": "/misc/feature-tracker/#cluster-creation", 
            "text": "Create the GKE cluster   Get cluster credentials ( /root/.kube/config  file)   Initialize Helm", 
            "title": "Cluster creation"
        }, 
        {
            "location": "/misc/feature-tracker/#cluster-access-control", 
            "text": "Add cluster namespaces (virtual clusters)   Add cluster roles and role bindings   Add cluster network policies", 
            "title": "Cluster access control"
        }, 
        {
            "location": "/misc/feature-tracker/#supporting-tools", 
            "text": "Install cluster ingress controller (cloud load balancer)   Install TLS certificates controller (kube-lego)   Install Continuous Delivery tools   Continuous delivery service (Drone / Jenkins)   Helm chart repository (ChartMuseum)   Private Docker registry   Git service (Gitlab / Gogs)     Monitoring and alerting tools (Prometheus / Grafana)", 
            "title": "Supporting tools"
        }, 
        {
            "location": "/misc/feature-tracker/#user-apps-and-services", 
            "text": "Install \"hello-world\" apps like static sites, Ruby on Rails apps, etc.", 
            "title": "User apps and services"
        }, 
        {
            "location": "/misc/secrets/", 
            "text": "Managing secrets\n\n\nWhat are secrets?\n\n\nSecrets\n are configuration values that are directly responsible for the security of a part of a DevOps system.\n\n\nExamples:\n\n\n\n\nGitHub OAuth application token pair\n\n\nCloudFlare \nemail:token\n pair\n\n\nPrivate Docker Registry \nusername:password\n pair\n\n\n\n\nManaging secrets is non-trivial.\n\n\nAll secrets currently not commited to VCS\n\n\n\n\n\n\n\n\nPath\n\n\nPurpose\n\n\nManagement strategy\n\n\n\n\n\n\n\n\n\n\ncredentials.json\n\n\nAuthenticate to GCP project\n\n\nCreate via GUI, use by the \ngcloud auth activate-service-account --key-file credentials.json\n, delete ?\n\n\n\n\n\n\n.env\n\n\nRandom TF_VAR_* variables\n\n\nCommit to VCS if only use to import values \nexport TF_VAR_mysecret=\n$(security find-generic-password -a mysecret -w)\n\n\n\n\n\n\nbackup/tls\n\n\nStore LE TLS certificates\n\n\nReplace with Ark, encrypt in VCS\n\n\n\n\n\n\nconfig/**\n\n\nAuto-generated config files for gcloud, kubectl, helm, terraform\n\n\nNever commit to VCS\n\n\n\n\n\n\nlive/prod/kube/**/secrets/**\n\n\nCreate Kubernetes Secrets via pre_hook (for now)\n\n\nReplace with Vault? Store encrypted VCS?", 
            "title": "Managing secrets in Exekube"
        }, 
        {
            "location": "/misc/secrets/#managing-secrets", 
            "text": "", 
            "title": "Managing secrets"
        }, 
        {
            "location": "/misc/secrets/#what-are-secrets", 
            "text": "Secrets  are configuration values that are directly responsible for the security of a part of a DevOps system.  Examples:   GitHub OAuth application token pair  CloudFlare  email:token  pair  Private Docker Registry  username:password  pair   Managing secrets is non-trivial.", 
            "title": "What are secrets?"
        }, 
        {
            "location": "/misc/secrets/#all-secrets-currently-not-commited-to-vcs", 
            "text": "Path  Purpose  Management strategy      credentials.json  Authenticate to GCP project  Create via GUI, use by the  gcloud auth activate-service-account --key-file credentials.json , delete ?    .env  Random TF_VAR_* variables  Commit to VCS if only use to import values  export TF_VAR_mysecret= $(security find-generic-password -a mysecret -w)    backup/tls  Store LE TLS certificates  Replace with Ark, encrypt in VCS    config/**  Auto-generated config files for gcloud, kubectl, helm, terraform  Never commit to VCS    live/prod/kube/**/secrets/**  Create Kubernetes Secrets via pre_hook (for now)  Replace with Vault? Store encrypted VCS?", 
            "title": "All secrets currently not commited to VCS"
        }
    ]
}